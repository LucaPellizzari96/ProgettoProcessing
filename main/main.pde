/**
  * This sketch demonstrates how to use an FFT to analyze
  * the audio being generated by an AudioPlayer.
  * <p>
  * FFT stands for Fast Fourier Transform, which is a 
  * method of analyzing audio that allows you to visualize 
  * the frequency content of a signal. You've seen 
  * visualizations like this before in music players 
  * and car stereos.
  * <p>
  * For more information about Minim and additional features, 
  * visit http://code.compartmental.net/minim/
  */

import ddf.minim.analysis.*;
import ddf.minim.*;

Minim minim;
AudioPlayer song;
FFT fft;
// personaggio e ostacoli
Character character = new Character();  // costruttore del personaggio
int numObstacles = 15; // numero di ostacoli
ArrayList<Obstacle> obstacles = new ArrayList<Obstacle>(); // array che contiene gli ostacoli
Spectrum2 spettri = new Spectrum2();
// costruzione ellisse
float a = 2; // dimensioni dell'ellisse (orizzontale); dimensione verticale b = 1 => non serve scriverla
float incrementoAngolo = 360.0/512.0; // incremento dell'angolo = numero di gradi/numero di campioni
float angolo = 0; // angolo per lo spettro attorno alla circonferenza (mappata in un'ellisse)
// variabili per lo spostamento su z
float zMin = 0.05;
float zMax = 2.45;

void setup()
{
  fullScreen(P3D);
  
  minim = new Minim(this);
  
  // specify that we want the audio buffers of the AudioPlayer
  // to be 1024 samples long because our FFT needs to have 
  // a power-of-two buffer size and this is a good size.
  song = minim.loadFile("../data/song.mp3", 1024);
  
  // loop the file indefinitely
  song.loop();
  
  // create an FFT object that has a time-domain buffer 
  // the same size as song's sample buffer
  // note that this needs to be a power of two 
  // and that it means the size of the spectrum will be half as large.
  fft = new FFT( song.bufferSize(), song.sampleRate() );
 
  // Inserisco gli ostacoli nell'arraylist
  for(int i = 0; i < numObstacles; i++){
   Obstacle obstacle = new Obstacle();
   obstacles.add(obstacle);
  }
  
} // void setup()

// Gestisco il movimento del personaggio
void keyPressed(){
  switch(keyCode){ // keyCode : variabile speciale per riconoscere alcuni caratteri particolari
    case UP:
      character.animate();
      break;
    case DOWN:
      character.invertAngle();
      break;
    case ENTER:
      character.gameOver = false;
      character.animation = true;
      break;
    default:
      break;
  }
} // keyPressed()

void draw()
{
  background(0);
  
  // perform a forward FFT on the samples in song's mix buffer,
  // which contains the mix of both the left and right channels of the file
  fft.forward( song.mix );
  
  float xDestraCharacter = character.getX() + character.raggio;
  float xSinistraCharacter = character.getX() - character.raggio;
  float yAltoCharacter = character.getY() + character.raggio;
  float yBassoCharacter = character.getY() - character.raggio;
  for(int i=0; i < numObstacles; i++){
    float xDestraOst = obstacles.get(i).getX() + obstacles.get(i).dim;
    float xSinistraOst = obstacles.get(i).getX() - obstacles.get(i).dim;
    float yAltoOst = obstacles.get(i).getY() + obstacles.get(i).dim;
    float yBassoOst = obstacles.get(i).getY() - obstacles.get(i).dim;
    float zPosOst = obstacles.get(i).getZ() + obstacles.get(i).dim;
    float zNegOst = obstacles.get(i).getZ() - obstacles.get(i).dim;
    if((xDestraOst > xSinistraCharacter && xDestraOst < xDestraCharacter) || (xSinistraOst > xSinistraCharacter && xSinistraOst < xDestraCharacter)){  // collisione su x
      if((yBassoOst > yAltoCharacter && yBassoOst < yBassoCharacter) || (yAltoOst > yBassoCharacter && yAltoOst < yAltoCharacter)){ // collisione su y
        if(character.getZ() < zPosOst && character.getZ() > zNegOst){
        character.gameOver = true;
        }
      }
    }
  } // for
  
  // Traslo per fare in modo che la scena sia al centro dello schermo
  translate(width/2, height/2, 0);
  
  stroke(255,0,0); // rosso
  character.display(); // grazie alla traslazione viene posizionato al centro (inizialmente)
  
  // Mostro gli ostacoli
  stroke(0,255,0); // verde
  for(int i = 0; i < numObstacles; i++){  
   obstacles.get(i).display();
  }
  
  stroke(0,0,255);  // blu
  
  spettri.display();
    
}  // void draw()
