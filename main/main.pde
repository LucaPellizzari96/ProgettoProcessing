/**
  * This sketch demonstrates how to use an FFT to analyze
  * the audio being generated by an AudioPlayer.
  * <p>
  * FFT stands for Fast Fourier Transform, which is a 
  * method of analyzing audio that allows you to visualize 
  * the frequency content of a signal. You've seen 
  * visualizations like this before in music players 
  * and car stereos.
  * <p>
  * For more information about Minim and additional features, 
  * visit http://code.compartmental.net/minim/
  */

import ddf.minim.analysis.*;
import ddf.minim.*;

Minim minim;
AudioPlayer song;
FFT fft;
Character character = new Character();  // costruttore del personaggio
int numObstacles = 50; // numero di ostacoli
ArrayList<Obstacle> obstacles = new ArrayList<Obstacle>(); // array che contiene gli ostacoli

void setup()
{
  fullScreen(P3D);
  //size(512, 512, P3D);
  
  minim = new Minim(this);
  
  // specify that we want the audio buffers of the AudioPlayer
  // to be 1024 samples long because our FFT needs to have 
  // a power-of-two buffer size and this is a good size.
  song = minim.loadFile("../data/song.mp3", 1024);
  
  // loop the file indefinitely
  song.loop();
  
  // create an FFT object that has a time-domain buffer 
  // the same size as song's sample buffer
  // note that this needs to be a power of two 
  // and that it means the size of the spectrum will be half as large.
  fft = new FFT( song.bufferSize(), song.sampleRate() );
 
  // Inserisco gli ostacoli nell'arraylist
  for(int i = 0; i < numObstacles; i++){
   Obstacle obstacle = new Obstacle();
   obstacles.add(obstacle);
  }
  
}

// Gestisco il movimento del personaggio tramite i tasti freccia
void keyPressed(){
  switch(keyCode){ // keyCode : variabile speciale per riconoscere alcuni caratteri particolari
    case UP:
      character.moveUp();
      break;
    case DOWN:
      character.moveDown();
      break;
    case LEFT:
      character.moveLeft();
      break;
    case RIGHT:
      character.moveRight();
      break;   
    default:
      break;
  }
} // keyPressed()

void draw()
{
  background(0);
  
  stroke(255,0,0); // rosso
  line(0, 0, width, 0); // asse x
  stroke(0,255,0); // verde  
  line(0, 0, 0, height); // asse y
  
  // perform a forward FFT on the samples in song's mix buffer,
  // which contains the mix of both the left and right channels of the file
  fft.forward( song.mix );
  
  /*
  for(int i = 0; i < fft.specSize(); i++)
  {
    // draw the line for frequency band i, scaling it up a bit so we can see it
    line( i, height, i, height - fft.getBand(i)*8 ); // spettro "lineare" di prova solo per vedere che sia corretto
    
  }
  */
  
  // Traslo per fare in modo che la scena sia al centro dello schermo
  translate(width/2, height/2, 0);
  
  character.display(); // grazie alla traslazione viene posizionato al centro (inizialmente)
  
  // Mostro gli ostacoli
  for(int i = 0; i < numObstacles; i++){
   stroke(0,0,255);
   obstacles.get(i).display();
  }
  
  for(int i = 0; i < fft.specSize(); i++){ // disegno lo spettro in forma circolare
    float raggio = map(fft.getBand(i), 0, 1, 200, 300);
    // moltiplico il raggio per allontanare la scena dal centro dello schermo
    line( 1.5*raggio*cos(radians(i)), 1.5*raggio*sin(radians(i)), 1.6*raggio*cos(radians(i)), 1.6*raggio*sin(radians(i)) );
    //line( 0, 0, 2*raggio*cos(radians(i)), 2*raggio*sin(radians(i)) );    
  }

}
